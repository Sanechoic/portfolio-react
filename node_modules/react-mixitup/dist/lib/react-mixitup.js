"use strict";
/**
 * @class ReactMixitup
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_flatten_1 = require("lodash.flatten");
var lodash_uniq_1 = require("lodash.uniq");
var React = require("react");
var OuterBound = React.memo(React.forwardRef(function (props, ref) { return (React.createElement("div", __assign({ style: { position: 'relative' } }, props, { ref: ref }))); }));
function init() {
    return {
        animate: false,
        commit: false,
        firstRender: true,
        hash: null,
        mount: false
    };
}
var getItemsHash = function (items) {
    return items.join(',');
};
function reducer(state, action) {
    switch (action.type) {
        case 'SET_HASH':
            if (typeof action.hash === 'undefined') {
                throw new Error();
            }
            var mount = true;
            if (state.firstRender ||
                state.mount ||
                state.commit /* || state.animate */ ||
                !action.transition) {
                mount = false;
            }
            return __assign({}, state, { hash: action.hash, firstRender: false, mount: mount });
        case 'COMMIT':
            return __assign({}, state, { commit: true, mount: false });
        case 'ANIMATE':
            return __assign({}, state, { animate: true, commit: false });
        case 'STOP_ANIMATION':
            return __assign({}, state, { animate: false, mount: false });
        default:
            throw new Error();
    }
}
function onNextFrame(callback) {
    setTimeout(function () {
        window.requestAnimationFrame(callback);
    }, 0);
}
var makeAbsoluteWrapper = function (Wrapper) {
    return React.memo(React.forwardRef(function (props, ref) { return (React.createElement(Wrapper, __assign({ style: {
            position: 'absolute',
            top: '0',
            left: '0',
            right: '0',
            visibility: 'hidden',
            zIndex: -1
        } }, props, { ref: ref }))); }));
};
var makeWrapper = function (ReactMixitupWrapper) {
    return React.memo(React.forwardRef(function (props, ref) { return React.createElement(ReactMixitupWrapper, __assign({}, props, { ref: ref })); }));
};
var ReactMixitup = React.memo(React.forwardRef(function (_a, outerBoundRef) {
    var unparsedItems = _a.items, _b = _a.duration, duration = _b === void 0 ? 500 : _b, renderCells = _a.renderCells, _c = _a.Wrapper, ReactMixitupWrapper = _c === void 0 ? 'div' : _c, _d = _a.transition, transition = _d === void 0 ? true : _d;
    var Wrapper = React.useMemo(function () { return makeWrapper(ReactMixitupWrapper); }, [ReactMixitupWrapper]);
    var AbsoluteWrapper = React.useMemo(function () { return makeAbsoluteWrapper(Wrapper); }, [Wrapper]);
    var items = unparsedItems.map(function (key) { return key.toString(); });
    var _e = React.useReducer(reducer, items, init), _f = _e[0], hash = _f.hash, animate = _f.animate, mount = _f.mount, commit = _f.commit, unsafeDispatch = _e[1];
    var unmounted = React.useRef(false);
    React.useEffect(function () { return function () {
        unmounted.current = true;
    }; }, []);
    var dispatch = React.useCallback(function (action) {
        if (unmounted.current) {
            return;
        }
        unsafeDispatch(action);
    }, []);
    var refs = React.useRef({
        states: [
            {
                items: items,
                positions: {},
                containerHeight: null
            }
        ],
        persistedElement: null
    });
    var newHash = getItemsHash(items);
    var newGrid = newHash !== hash;
    /* just to handle if clicking really fast, then ignore the update */
    if (mount || commit) {
        newGrid = false;
        newHash = hash;
    }
    var currentState = refs.current.states[refs.current.states.length - 1];
    if (newGrid) {
        var nextState = {
            items: items,
            positions: {},
            containerHeight: null
        };
        if (animate) {
            refs.current.states.push(nextState);
        }
        else {
            refs.current.states = [currentState, nextState];
        }
        currentState = refs.current.states[refs.current.states.length - 1];
    }
    var states = refs.current.states;
    React.useEffect(function () {
        if (newGrid) {
            dispatch({
                type: 'SET_HASH',
                hash: newHash,
                transition: transition
            });
        }
    }, [newHash, newGrid, transition]);
    React.useEffect(function () {
        if (mount) {
            /* make sure the mount has been committed to the DOM, double make sure by wrapping in onNextFrame */
            onNextFrame(function () {
                dispatch({
                    type: 'COMMIT'
                });
            });
        }
    }, [mount]);
    React.useEffect(function () {
        if (commit) {
            onNextFrame(function () {
                dispatch({
                    type: 'ANIMATE'
                });
            });
        }
    }, [commit]);
    React.useEffect(function () {
        var timer;
        var clear = function () {
            window.clearTimeout(timer);
        };
        if (animate) {
            timer = window.setTimeout(function () {
                dispatch({
                    type: 'STOP_ANIMATION'
                });
            }, duration);
        }
        else {
            clear();
        }
        return clear;
    }, [animate, newHash]);
    var measureRef = React.useCallback(function (key, el) {
        // console.log(index, states, key);
        refs.current.states[refs.current.states.length - 1].positions[key] = {
            x: el.offsetLeft,
            y: el.offsetTop
        };
    }, []);
    var wrapperMeasureContainerHeight = React.useCallback(function (el) {
        if (!el) {
            return;
        }
        refs.current.states[refs.current.states.length - 1].containerHeight = el.offsetHeight;
    }, []);
    var rows = React.useCallback(function (_a) {
        var itemsToRender = _a.itemsToRender, ref = _a.ref, style = _a.style;
        var makeRef = function (key) {
            if (typeof ref === 'undefined') {
                return;
            }
            return function (el) {
                if (el) {
                    ref(key, el);
                }
            };
        };
        var makeStyle = function (key) {
            return typeof style !== 'undefined' ? style(key) : undefined;
        };
        return renderCells(itemsToRender.map(function (key) { return ({
            key: key,
            ref: makeRef(key),
            style: makeStyle(key)
        }); }));
    }, [renderCells]);
    var latestIndex = states.length - 1;
    if (commit) {
        return refs.current.persistedElement;
    }
    var measureNewGrid = newGrid ? (React.createElement(AbsoluteWrapper, { ref: wrapperMeasureContainerHeight }, rows({
        itemsToRender: currentState.items,
        ref: measureRef
    }))) : null;
    if (!transition) {
        return (React.createElement(OuterBound, { ref: outerBoundRef },
            React.createElement(Wrapper, null, rows({
                itemsToRender: currentState.items
            }))));
    }
    var child = (React.createElement(React.Fragment, null,
        React.createElement(Wrapper, null, rows({
            itemsToRender: currentState.items
        })),
        measureNewGrid));
    if (newGrid) {
        /* AND !animate AND !mount */
        /* measure stage */
        child = (React.createElement(React.Fragment, null,
            React.createElement(Wrapper, null, rows({
                itemsToRender: states.length > 1 ? states[states.length - 2].items : states[0].items
            })),
            measureNewGrid));
    }
    var getItemStateIndexes = function (item) {
        var indexes = [];
        for (var i = states.length - 1; i >= 0; i -= 1) {
            var state = states[i];
            if (state.items.includes(item)) {
                indexes.push(i);
            }
        }
        return indexes;
    };
    var allItems = lodash_flatten_1.default(states.map(function (_a) {
        var sItems = _a.items;
        return sItems;
    }));
    var getLatestPositions = function (item) {
        for (var i = states.length - 1; i >= 0; i -= 1) {
            var state = states[i];
            if (state.positions[item]) {
                return state.positions[item];
            }
        }
        return undefined;
    };
    var animationRenderItems = lodash_uniq_1.default(allItems)
        .sort()
        .filter(getLatestPositions);
    if (mount) {
        // debugger;
        child = (React.createElement(React.Fragment, null,
            React.createElement(Wrapper, { style: { height: states[states.length - 2].containerHeight + 'px' } }, rows({
                itemsToRender: animationRenderItems,
                style: function (key) {
                    var _a, _b;
                    var z = 1;
                    var x = 0;
                    var y = 0;
                    var indexes = getItemStateIndexes(key);
                    if (indexes.length === 0) {
                        throw new Error('something went wrong in the lib');
                    }
                    /* the new items (indexes[0] === latestIndex) that has a previous position */
                    (_a = states[indexes[0]].positions[key], x = _a.x, y = _a.y);
                    if (indexes[0] === latestIndex) {
                        if (indexes.length > 1) {
                            /* move from previous position */
                            (_b = states[indexes[1]].positions[key], x = _b.x, y = _b.y);
                        }
                        else {
                            /* appear at current position */
                            z = 0;
                        }
                    }
                    var transform = "translate3d(" + [x, y, 0].join('px,') + "px) scale(" + z + ")";
                    var style = {
                        transform: transform,
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        margin: 0
                    };
                    return style;
                }
            }))));
    }
    if (animate) {
        // debugger;
        child = (React.createElement(React.Fragment, null,
            React.createElement(Wrapper, { style: { height: currentState.containerHeight + 'px' } }, rows({
                /* they must have been measured */
                itemsToRender: animationRenderItems,
                style: function (key) {
                    var z = 1;
                    var x = 0;
                    var y = 0;
                    var indexes = getItemStateIndexes(key);
                    if (indexes.length === 0) {
                        throw new Error('something went wrong in the lib');
                    }
                    var latestPosition = getLatestPositions(key);
                    if (!latestPosition) {
                        throw new Error('This should not happed since filtering');
                    }
                    (x = latestPosition.x, y = latestPosition.y);
                    // /* was just added */
                    if (indexes.length === 1 && latestIndex === indexes[0] && mount) {
                        z = 0;
                    }
                    /* will be removed */
                    if (!currentState.items.includes(key)) {
                        z = 0;
                    }
                    var transform = "translate3d(" + [x, y, 0].join('px,') + "px) scale(" + z + ")";
                    var style = {
                        transform: transform,
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        margin: 0,
                        transition: "transform " + duration + "ms ease"
                    };
                    return style;
                }
            })),
            measureNewGrid));
    }
    refs.current.persistedElement = React.createElement(OuterBound, { ref: outerBoundRef }, child);
    return refs.current.persistedElement;
}));
exports.default = ReactMixitup;
//# sourceMappingURL=react-mixitup.js.map